## PyGan edi_compo.py procedure to handle calls to EDI: and COMPO: modues
# Author : R. Guasch
# Date : 2025-06-04

import lcm
import cle2000
import lifo
import numpy as np
import os

# mix_numbering_option, flux_lcm, lib_ssh, track_lcm, name_compo, save_option="SAVE", mix_connectivity_dict=connectivity_dict
def ediCompo(mix_numbering_option, flux_lcm, self_shielded_microlib, track_lcm, name_compo, save_option, mix_connectivity_dict=None):
    """
    This function prepares a DRAGON5 EDI: and COMPO: procedure call.
    It handles the composition and cross-section data for the ATRIUM-10 BWR fuel assembly.
    
    Parameters:
    ----------
    mix_numbering_option : str
        Option for mix numbering (e.g., "number_mix_families_per_enrichment").
    flux_lcm : lcm object
        LCM object containing the flux data.
    self_shielded_microlib : lcm object
        LCM object containing the self-shielded cross sections library.
    track_lcm : lcm object
        LCM object containing the tracking results.
    name_compo : str
        Name of the composition to be processed.
    save_option : str
        Option to save the composition data (e.g., "SAVE") or if it should only be returned for later modification.

    Returns:
    ----------
    compo_lcm : lcm object
        LCM object containing the composition results.
    """
    
    if mix_numbering_option == "number_mix_families_per_enrichment":
        # Initialize the LIFO stack for EDI: and COMPO: procedure
        ipLifo = lifo.new()
        
        # Push necessary data onto the LIFO stack
        """
        PARAMETER COMPO FLUX LIBRARY2 TRACK ::
        ::: LINKED_LIST COMPO ;
        ::: LINKED_LIST FLUX ;
        ::: LINKED_LIST LIBRARY2 ;
        ::: LINKED_LIST TRACK ; ;
        STRING name_cpo save_opt ;
        :: >>name_cpo<< >>save_opt<< ;
        """
        ipLifo.pushEmpty("COMPO", "LCM")
        ipLifo.push(flux_lcm)
        ipLifo.push(self_shielded_microlib)
        ipLifo.push(track_lcm)
        ipLifo.push(name_compo)
        ipLifo.push(save_option)  # Save option for the composition data

        # Create a cle2000 object to handle the EDI: and COMPO: procedure call
        edi_compo_proc = cle2000.new('EDICPO1', ipLifo, 1)
        
        # Execute the EDI_COMPO procedure
        edi_compo_proc.exec()

        # Recover the results from the LIFO stack
        ipLifo.lib()
        compo_lcm = ipLifo.node('COMPO')

        return compo_lcm
    
    elif mix_numbering_option == "number_mix_families_per_region":
        # Create the EDICPO_R procedure for region-based numbering
        proc_name = 'EDICPO_R.c2m'
        # Fill the procedure with the necessary parameters
        fill_edi_compo_proc(proc_name, mix_numbering_option, mix_connectivity_dict, iso_list=["U235", "U238", "U234", "Gd155", "Gd157"])
        os.chmod(proc_name, 0o755)  # Make the procedure executable

        # Initialize the LIFO stack for EDI: and COMPO: procedure
        ipLifo = lifo.new()
        # Push necessary data onto the LIFO stack
        """
        PARAMETER COMPO FLUX LIBRARY2 TRACK ::
        ::: LINKED_LIST COMPO ;
        ::: LINKED_LIST FLUX ;
        ::: LINKED_LIST LIBRARY2 ;
        ::: LINKED_LIST TRACK ; ;
        STRING name_cpo save_opt ;
        :: >>name_cpo<< >>save_opt<< ; 
        """
        ipLifo.pushEmpty("COMPO", "LCM")
        ipLifo.push(flux_lcm)
        ipLifo.push(self_shielded_microlib)
        ipLifo.push(track_lcm)
        ipLifo.push(name_compo)
        ipLifo.push(save_option)  # Save option for the composition data

        # Create a cle2000 object to handle the EDI: and COMPO: procedure call
        edi_compo_proc = cle2000.new(proc_name.split(".")[0], ipLifo, 1)
        # Execute the EDI_COMPO procedure
        edi_compo_proc.exec()
        # Recover the results from the LIFO stack
        ipLifo.lib()
        compo_lcm = ipLifo.node('COMPO')
        
        return compo_lcm


def fill_edi_compo_proc(proc_name, mix_numbering_option, mix_connectivity_dict, iso_list):
    """
    Function used to fill the prcedure calling EDI: and COMPO: modules for rates condensation / homogenization.
    By default : assume that the EDI: call with provide with a 
    """

    header = (
            f"* PROCEDURE {proc_name} : calls to EDI: and COMPO: modules\n"
            "* --------------------------------\n"
            "* Procedure generated by edi_compo.py\n"
            "* Author: R. Guasch\n"  
            "* --------------------------------\n"
            "*    INPUT & OUTPUT PARAMETERS\n"
            "* --------------------------------\n"
            "PARAMETER COMPO FLUX LIBRARY2 TRACK ::\n"
            "::: LINKED_LIST COMPO ;\n"
            "::: LINKED_LIST FLUX ;\n"
            "::: LINKED_LIST LIBRARY2 ;\n"
            "::: LINKED_LIST TRACK ; ;\n"
            "STRING name_cpo save_opt ;\n"
            ":: >>name_cpo<< >>save_opt<< ; ! save option for COMPO: module, e.g. 'SAVE' or 'NOSAVE'\n"
            "* --------------------------------\n"
            "*    MODULES DEFINITION\n"
            "* --------------------------------\n"
            "MODULE EDI: COMPO: DELETE: END: ;\n"
            "* --------------------------------\n"
            "*    LOCAL VARIABLES DEFINITION\n"
            "* --------------------------------\n"
            "LINKED_LIST EDIRATES ;\n"
            "* --------------------------------\n"
            "*    COMPO FILE NAME FOR EXPORT\n"
            "* --------------------------------\n"
            "SEQ_ASCII _COMPO :: FILE <<name_cpo>> ;\n"
            )
    
    edi_cpo_proc = (
        f"{header}"
        "* --------------------------------\n"
        f"*   COMPO INITIALIZATION\n"
        "* --------------------------------\n"
        f"{initialize_cpo(mix_numbering_option, iso_list)}\n"
        "* --------------------------------\n"
        f"*    EDI: CALL FOR EDIHOM\n"
        "* --------------------------------\n"
        f"{fill_EDI_call('EDIHOM_COND', [], 'FUEL', iso_list, mix_connectivity_dict)}\n"
        f"* --------------------------------\n"
        f"*    COMPO: CALL FOR EDIHOM\n"
        "* --------------------------------\n"
        f"{fill_COMPO_call('EDIHOM_COND')}\n"
        f"EDIRATES := DELETE: EDIRATES ;\n"
        "* --------------------------------\n"
        f"*    EDI: CALL FOR EDIHOM_295\n"
        "* --------------------------------\n"
        f"{fill_EDI_call('EDIHOM_295', None, 'ALL', iso_list, mix_connectivity_dict)}\n"
        f"* --------------------------------\n"
        f"*    COMPO: CALL FOR EDIHOM_295\n"
        "* --------------------------------\n"
        f"{fill_COMPO_call('EDIHOM_295')}\n"
        "* --------------------------------\n"
        f"EDIRATES := DELETE: EDIRATES ;\n"
        
        "* --------------------------------\n"
        f"*    EDI: CALL FOR U238_295\n"
        "* --------------------------------\n"
        f"{fill_EDI_call('U238_295', None, 'numbering', ['U238'], mix_connectivity_dict)}\n"
        f"* --------------------------------\n"
        f"*    COMPO: CALL FOR U238_295\n"
        "* --------------------------------\n"
        f"{fill_COMPO_call('U238_295')}\n"
        "* --------------------------------\n"
        f"EDIRATES := DELETE: EDIRATES ;\n"
        
        
        "* --------------------------------\n"
        f"*    EDI: CALL FOR REGI_1g\n"
        f"* --------------------------------\n"
        f"{fill_EDI_call(f'H_EDI_REGI_1g', [], 'numbering', iso_list, mix_connectivity_dict)}\n"
        f"* --------------------------------\n"
        f"*    COMPO: CALL FOR REGI_1g\n"
        f"* --------------------------------\n"
        f"{fill_COMPO_call(f'H_EDI_REGI_1g')}\n"
        "* --------------------------------\n"
        f"EDIRATES := DELETE: EDIRATES ;\n"
        "* --------------------------------\n"
        f"*    EDI: CALL FOR REGI_2g\n"
        f"* --------------------------------\n"
        f"{fill_EDI_call(f'H_EDI_REGI_2g', [0.625], 'numbering', iso_list, mix_connectivity_dict)}\n"
        f"* --------------------------------\n"
        f"*    COMPO: CALL FOR REGI_2g\n"
        f"* --------------------------------\n"
        f"{fill_COMPO_call(f'H_EDI_REGI_2g')}\n"
        "* --------------------------------\n"
        f"EDIRATES := DELETE: EDIRATES ;\n"
        "* --------------------------------\n"
        "IF save_opt 'SAVE' = THEN\n"
        "   _COMPO := COMPO ;\n"
        "ENDIF ;\n"
        "END: ;\n"
    )
    #print(f"Generated EDI: and COMPO: procedure:\n{edi_cpo_proc}")
    # Write the procedure to a file
    with open(proc_name, 'w') as proc_file:
        proc_file.write(edi_cpo_proc)
    proc_file.close()
    return


def initialize_cpo(mix_numbering_option, list_isos):
    """
    Initialize COMPO object with specified directories through STEP UP "DIRNAME" keyword.
    """
    if mix_numbering_option == "number_mix_families_per_region":
        DIRNAME = "H_EDI_REGI"
        comment = "Homogenized over unique regions"
    elif mix_numbering_option == "number_mix_families_per_enrichment":
        DIRNAME = "H_EDI_ENRI"
        comment = "Homogenized over unique enrichments"
    elif mix_numbering_option == "number_mix_per_self_shielding_family":
        DIRNAME = "H_EDI_SSH"
        comment = "Homogenized over self-shielding families"

    iso_formatted = " ".join(list_isos)
    cpo_init = (
        "COMPO := COMPO: ::\n"
        "   STEP UP 'EDIHOM_COND'\n"
        "       COMM 'Reaction rates - Condensed, Homogenized over all fuel cells' ENDC\n"
        f"      ISOT {len(list_isos)} {iso_formatted}\n"
        "   INIT\n"
        "   STEP UP 'EDIHOM_295'\n"
        "       COMM 'Reaction rates - Homogenized, 295g' ENDC\n"
        f"      ISOT {len(list_isos)} {iso_formatted}\n"
        "   INIT\n"
        "   STEP UP 'U235_295'\n"
        "       COMM 'U238 rates - Homogenized over all fuel cells, 295g' ENDC\n"
        f"      ISOT 1 U238\n"
        "   INIT\n"
        f"   STEP UP '{DIRNAME}_1g'\n"
        f"       COMM 'Reaction rates - Condensed, {comment}' ENDC\n"
        f"      ISOT {len(list_isos)} {iso_formatted}\n"
        "   INIT\n"
        f"   STEP UP '{DIRNAME}_2g'\n"
        f"       COMM 'Reaction rates- Condensed to 2 groups, {comment}' ENDC\n"
        f"      ISOT {len(list_isos)} {iso_formatted}\n"
        "   INIT\n"
        ";\n"
    )
    return cpo_init.strip()


def fill_EDI_call(DIRNAME, energy_mesh_for_condensation, spatial_homogenisation, iso_list, mix_connectivity_dict):
    """
    fill sample call to EDI: module,
    restricting use cases to compute reaction rates through microlib, flux and track lcm objects

    """
    formatted_iso_list = " ".join(iso_list)
    if energy_mesh_for_condensation is not None:
        if energy_mesh_for_condensation == []:
            cond_option = "COND" # condensation on the whole energy range
        else: # a list of energy bounds is specified
            energy_mesh = " ".join(map(str, energy_mesh_for_condensation))
            cond_option = f"COND {energy_mesh}"
    else:
        cond_option = ""
    
    merge_mix_option = getMixIndicesFromConnectivityDict(mix_connectivity_dict, spatial_homogenisation)

    
    call_to_EDI = (
        "EDIRATES := EDI: FLUX LIBRARY2 TRACK ::\n"
        "   EDIT 1\n"
        f"  MICR {len(iso_list)} {formatted_iso_list}\n"
        "   MERG MIX\n" 
        f"  {merge_mix_option}\n"
        f"  {cond_option}\n"
        f"  SAVE ON {DIRNAME}\n"
        ";\n"
        )
    
    return call_to_EDI.strip()

def getMixIndicesFromConnectivityDict(mix_connectivity_dict, spatial_homogenisation):
    """
    Generate the argument for the MERG MIX keyword
    The logic is that  : - the index (position) in MERG MIX argument corresponds to the MIX number from chosen mix numbering option.
                         - the entry (actual number) in MERG MIX argument corresponds to the new mix number that will be used in to identify 
                        the calculated homogenized properties in the output COMPO.
    Parameters:
    ----------
    mix_connectivity_dict : dict
        Dictionary containing the connectivity information for mixes.
    spatial_homogenisation : str
        Flag indicating what type of spatial homogenisation is to be performed.
        Can be "FUEL" or "ALL". If "FUEL", all fuel mixes are homogenized together in the output EDITION / COMPO file.
                                If "ALL", all mixes are homogenized together in the output EDITION / COMPO file.
                                If "numbering" : the mix_connectivity_dict is used to determine the homogenization, based on unique regions, enrichments etc ...
    Returns:    
    ----------
    merg_mix_argument : str
        Formatted string for the MERG MIX argument.
    """
    
    MERGMIX_LIST = np.zeros(len(mix_connectivity_dict), dtype=int) # Index in MERGMIX_LIST corresponds to the mix number from chosen mix numbering option
    # Number (integer) entry in MERGMIX_LIST corresponds to the new mix number that will be used in to identify the calculated homogenized properties in the output COMPO. 
    # Ie this is the unique_id given to a specific mix.
    mergmix_argument = ""
    for key in mix_connectivity_dict.keys():
        mix_index = mix_connectivity_dict[key]
        if key.startswith("FMIX_"):
            _, composition_id, unique_id, ring_id = key.split("_")
            if spatial_homogenisation == "numbering":
                MERGMIX_LIST[mix_index-1] = int(unique_id)  # Store the unique ID in the MERGMIX_LIST at the index corresponding to the mix number
            elif spatial_homogenisation == "FUEL" or spatial_homogenisation == "ALL":
                # If spatial homogenisation is FUEL, we use the ring_id as the unique identifier for the mix
                MERGMIX_LIST[mix_index-1] = 1
        else:
            unique_id = key
            if spatial_homogenisation == "numbering" or spatial_homogenisation == "FUEL": # Exclude non-fuel mixes from the MERG MIX argument
                MERGMIX_LIST[mix_index-1] = 0
            elif spatial_homogenisation == "ALL":
                MERGMIX_LIST[mix_index-1] = 1
        
        #print(f"Processing mix {key} with index {mix_index} and unique ID {unique_id}")
    # Format MERGMIX_LIST to create the mergmix_argument
    for index, unique_id in enumerate(MERGMIX_LIST):
        mergmix_argument += f"{unique_id} "
        if index % 10 == 9:
            mergmix_argument += "\n"
    #print(f"Generated MERG MIX argument: {mergmix_argument.strip()}")

    return mergmix_argument.strip()

def fill_COMPO_call(DIRNAME):
    """
    Fill calls to COMPO: module based on the DIRNAME provided in the initialization.
    """
    compo_call = (
    "COMPO := COMPO: COMPO EDIRATES LIBRARY2 ::\n"
    "   EDIT 1\n"
    f"    STEP UP {DIRNAME}\n"
    ";\n"
    )
    return compo_call.strip()


def condense295To26Groups(flux_lcm_lvl1, self_shielded_microlib, track_lcm_lvl1, track_binary_lvl1):
    """
    Function to condense reaction rates from 295 groups to 26 groups using EDI: module.
    """
    # Initialize the LIFO stack for the condensation process
    ipLifo = lifo.new()
    
    # Push necessary data onto the LIFO stack
    """
    PARAMETER LIBEQ  FLUXLVL1 LIBRARY2 TRACKLVL1 ::  
    ::: LINKED_LIST LIBEQ  ; 
    ::: LINKED_LIST FLUXLVL1  ;
    ::: LINKED_LIST LIBRARY2  ;
    ::: LINKED_LIST TRACKLVL1  ;
    ::: SEQ_BINARY TRACKBINARY  ;
   ;
    """
    ipLifo.pushEmpty("LIBEQ", "LCM")
    ipLifo.push(flux_lcm_lvl1)
    ipLifo.push(self_shielded_microlib)
    ipLifo.push(track_lcm_lvl1)
    ipLifo.push(track_binary_lvl1)

    # Create a cle2000 object to handle the EDI: procedure call for condensation
    compo_proc = cle2000.new('EDICOND', ipLifo, 1)
    
    # Execute the condensation operation
    compo_proc.exec()

    # Recover the results from the LIFO stack
    ipLifo.lib()
    lib_26g = ipLifo.node('LIBEQ')
    print("Condensation to 26 groups completed.")
    return lib_26g


def saveLVL1Compo(flux_lcm_lvl1, self_shielded_microlib, track_lcm_lvl1, name_compo):
    """
    Function to save a COMPO: file from the 1-level flux calculation. 
    
    """
    
    ipLifo = lifo.new()
    # Push necessary data onto the LIFO stack
    """
    
    PARAMETER FLUX LIBRARY2 TRACK ::
    ::: LINKED_LIST FLUX ;
    ::: LINKED_LIST LIBRARY2 ;
    ::: LINKED_LIST TRACK ; ;
    STRING name_cpo save_opt ;
    :: >>name_cpo<< >>save_opt<< ; ! save option  e.g. 'SAVE' or 'NOSAVE'
    """
    
    ipLifo.push(flux_lcm_lvl1)
    ipLifo.push(self_shielded_microlib)
    ipLifo.push(track_lcm_lvl1)
    ipLifo.push(name_compo)
    ipLifo.push("SAVE")  # Save option for the composition data
    # Create a cle2000 object to handle the EDI: and COMPO: procedure call
    edi_compo_proc = cle2000.new('EDICPO_LVL1', ipLifo, 1)
    # Execute the EDI_COMPO procedure
    edi_compo_proc.exec()
    # Recover the results from the LIFO stack
    ipLifo.lib()
    return

