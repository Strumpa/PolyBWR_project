## PyGan edi_compo.py procedure to handle calls to EDI: and COMPO: modues
# Author : R. Guasch
# Date : 2025-06-04

import lcm
import cle2000
import lifo
import numpy as np
import os

# mix_numbering_option, flux_lcm, lib_ssh, track_lcm, name_compo, save_option="SAVE", mix_connectivity_dict=connectivity_dict
def ediCompoRates(compo_lcm, flux_lcm, self_shielded_microlib, track_lcm, burnup_lcm, BU):
    """
    This function prepares a DRAGON5 EDI: and COMPO: procedure call.
    It handles the composition and cross-section data for the ATRIUM-10 BWR fuel assembly.
    
    Parameters:
    ----------
    mix_numbering_option : str
        Option for mix numbering (e.g., "number_mix_families_per_enrichment").
    flux_lcm : lcm object
        LCM object containing the flux data.
    self_shielded_microlib : lcm object
        LCM object containing the self-shielded cross sections library.
    track_lcm : lcm object
        LCM object containing the tracking results.
    name_compo : str
        Name of the composition to be processed.
    save_option : str
        Option to save the composition data (e.g., "SAVE") or if it should only be returned for later modification.

    Returns:
    ----------
    compo_lcm : lcm object
        LCM object containing the composition results.
    """
    
    proc_name = 'EDICPO_R.c2m'

    # Initialize the LIFO stack for EDI: and COMPO: procedure
    ipLifo = lifo.new()
    # Push necessary data onto the LIFO stack
    if BU > 0:
        ipLifo.push(compo_lcm)  # Push previous composition data for burnup > 0
    else:
        ipLifo.pushEmpty("COMPORATES", "LCM")
    ipLifo.push(flux_lcm)
    ipLifo.push(self_shielded_microlib)
    ipLifo.push(track_lcm)
    ipLifo.push(burnup_lcm)
    ipLifo.push(BU)  # Burnup step in MWd/tU

    # Create a cle2000 object to handle the EDI: and COMPO: procedure call
    edi_compo_proc = cle2000.new(proc_name.split(".")[0], ipLifo, 1)
    # Execute the EDI_COMPO procedure
    edi_compo_proc.exec()
    # Recover the results from the LIFO stack
    ipLifo.lib()
    compo_lcm = ipLifo.node('COMPORATES')
        
    return compo_lcm


def fill_edi_compo_proc(proc_name, mix_numbering_option, mix_connectivity_dict, iso_list):
    """
    Function used to fill the prcedure calling EDI: and COMPO: modules for rates condensation / homogenization.
    By default : assume that the EDI: call with provide with a 
    """

    header = (
            f"* PROCEDURE {proc_name} : calls to EDI: and COMPO: modules\n"
            "* --------------------------------\n"
            "* Procedure generated by edi_compo.py\n"
            "* Author: R. Guasch\n"  
            "* --------------------------------\n"
            "*    INPUT & OUTPUT PARAMETERS\n"
            "* --------------------------------\n"
            "PARAMETER COMPO FLUX LIBRARY2 TRACK ::\n"
            "::: LINKED_LIST COMPO ;\n"
            "::: LINKED_LIST FLUX ;\n"
            "::: LINKED_LIST LIBRARY2 ;\n"
            "::: LINKED_LIST TRACK ; ;\n"
            "STRING name_cpo save_opt ;\n"
            ":: >>name_cpo<< >>save_opt<< ; ! save option for COMPO: module, e.g. 'SAVE' or 'NOSAVE'\n"
            "* --------------------------------\n"
            "*    MODULES DEFINITION\n"
            "* --------------------------------\n"
            "MODULE EDI: COMPO: DELETE: END: ;\n"
            "* --------------------------------\n"
            "*    LOCAL VARIABLES DEFINITION\n"
            "* --------------------------------\n"
            "LINKED_LIST EDIRATES ;\n"
            "* --------------------------------\n"
            "*    COMPO FILE NAME FOR EXPORT\n"
            "* --------------------------------\n"
            "SEQ_ASCII _COMPO :: FILE <<name_cpo>> ;\n"
            )
    
    edi_cpo_proc = (
        f"{header}"
        "* --------------------------------\n"
        f"*   COMPO INITIALIZATION\n"
        "* --------------------------------\n"
        f"{initialize_cpo(mix_numbering_option, iso_list)}\n"
        "* --------------------------------\n"
        f"*    EDI: CALL FOR EDIHOM\n"
        "* --------------------------------\n"
        f"{fill_EDI_call('EDIHOM_COND', [], 'FUEL', iso_list, mix_connectivity_dict)}\n"
        f"* --------------------------------\n"
        f"*    COMPO: CALL FOR EDIHOM\n"
        "* --------------------------------\n"
        f"{fill_COMPO_call('EDIHOM_COND')}\n"
        f"EDIRATES := DELETE: EDIRATES ;\n"
        "* --------------------------------\n"
        f"*    EDI: CALL FOR EDIHOM_295\n"
        "* --------------------------------\n"
        f"{fill_EDI_call('EDIHOM_295', None, 'ALL', iso_list, mix_connectivity_dict)}\n" # Fill by retrieving energy mesh from ENE_MESH_handling
        f"* --------------------------------\n"
        f"*    COMPO: CALL FOR EDIHOM_295\n"
        "* --------------------------------\n"
        f"{fill_COMPO_call('EDIHOM_295')}\n"
        "* --------------------------------\n"
        f"EDIRATES := DELETE: EDIRATES ;\n"
        "* --------------------------------\n"
        f"*    EDI: CALL FOR REGI_1g\n"
        f"* --------------------------------\n"
        f"{fill_EDI_call(f'H_EDI_REGI_1g', [], 'numbering', iso_list, mix_connectivity_dict)}\n"
        f"* --------------------------------\n"
        f"*    COMPO: CALL FOR REGI_1g\n"
        f"* --------------------------------\n"
        f"{fill_COMPO_call(f'H_EDI_REGI_1g')}\n"
        "* --------------------------------\n"
        f"EDIRATES := DELETE: EDIRATES ;\n"
        "* --------------------------------\n"
        f"*    EDI: CALL FOR REGI_2g\n"
        f"* --------------------------------\n"
        f"{fill_EDI_call(f'H_EDI_REGI_2g', [0.625], 'numbering', iso_list, mix_connectivity_dict)}\n"
        f"* --------------------------------\n"
        f"*    COMPO: CALL FOR REGI_2g\n"
        f"* --------------------------------\n"
        f"{fill_COMPO_call(f'H_EDI_REGI_2g')}\n"
        "* --------------------------------\n"
        f"EDIRATES := DELETE: EDIRATES ;\n"
        "* --------------------------------\n"
        "IF save_opt 'SAVE' = THEN\n"
        "   _COMPO := COMPO ;\n"
        "ENDIF ;\n"
        "END: ;\n"
    )
    #print(f"Generated EDI: and COMPO: procedure:\n{edi_cpo_proc}")
    # Write the procedure to a file
    with open(proc_name, 'w') as proc_file:
        proc_file.write(edi_cpo_proc)
    proc_file.close()
    return


def initialize_cpo(mix_numbering_option, list_isos):
    """
    Initialize COMPO object with specified directories through STEP UP "DIRNAME" keyword.
    """
    if mix_numbering_option == "number_mix_families_per_region":
        DIRNAME = "H_EDI_REGI"
        comment = "Homogenized over unique regions"
    elif mix_numbering_option == "number_mix_families_per_enrichment":
        DIRNAME = "H_EDI_ENRI"
        comment = "Homogenized over unique enrichments"
    elif mix_numbering_option == "number_mix_per_self_shielding_family":
        DIRNAME = "H_EDI_SSH"
        comment = "Homogenized over self-shielding families"

    iso_formatted = " ".join(list_isos)
    cpo_init = (
        "COMPO := COMPO: ::\n"
        "   STEP UP 'EDIHOM_COND'\n"
        "       COMM 'Reaction rates - Condensed, Homogenized over all fuel cells' ENDC\n"
        f"      ISOT {len(list_isos)} {iso_formatted}\n"
        "   INIT\n"
        "   STEP UP 'EDIHOM_295'\n"
        "       COMM 'Reaction rates - Homogenized over all fuel cells, 295g' ENDC\n"
        f"      ISOT {len(list_isos)} {iso_formatted}\n"
        "   INIT\n"
        f"   STEP UP '{DIRNAME}_1g'\n"
        f"       COMM 'Reaction rates - Condensed, {comment}' ENDC\n"
        f"      ISOT {len(list_isos)} {iso_formatted}\n"
        "   INIT\n"
        f"   STEP UP '{DIRNAME}_2g'\n"
        f"       COMM 'Reaction rates- Condensed to 2 groups, {comment}' ENDC\n"
        f"      ISOT {len(list_isos)} {iso_formatted}\n"
        "   INIT\n"
        ";\n"
    )
    return cpo_init.strip()


def fill_EDI_call(DIRNAME, energy_mesh_for_condensation, spatial_homogenisation, iso_list, mix_connectivity_dict):
    """
    fill sample call to EDI: module,
    restricting use cases to compute reaction rates through microlib, flux and track lcm objects

    """
    formatted_iso_list = " ".join(iso_list)
    if energy_mesh_for_condensation is not None:
        if energy_mesh_for_condensation == []:
            cond_option = "COND" # condensation on the whole energy range
        else: # a list of energy bounds is specified
            energy_mesh = " ".join(map(str, energy_mesh_for_condensation))
            cond_option = f"COND {energy_mesh}"
    else:
        cond_option = ""
    
    merge_mix_option = getMixIndicesFromConnectivityDict(mix_connectivity_dict, spatial_homogenisation)

    
    call_to_EDI = (
        "EDIRATES := EDI: FLUX LIBRARY2 TRACK ::\n"
        "   EDIT 1\n"
        f"  MICR {len(iso_list)} {formatted_iso_list}\n"
        "   MERG MIX\n" 
        f"  {merge_mix_option}\n"
        f"  {cond_option}\n"
        f"  SAVE ON {DIRNAME}\n"
        ";\n"
        )
    
    return call_to_EDI.strip()

def getMixIndicesFromConnectivityDict(mix_connectivity_dict, spatial_homogenisation):
    """
    Generate the argument for the MERG MIX keyword
    The logic is that  : - the index (position) in MERG MIX argument corresponds to the MIX number from chosen mix numbering option.
                         - the entry (actual number) in MERG MIX argument corresponds to the new mix number that will be used in to identify 
                        the calculated homogenized properties in the output COMPO.
    Parameters:
    ----------
    mix_connectivity_dict : dict
        Dictionary containing the connectivity information for mixes.
    spatial_homogenisation : str
        Flag indicating what type of spatial homogenisation is to be performed.
        Can be "FUEL" or "ALL". If "FUEL", all fuel mixes are homogenized together in the output EDITION / COMPO file.
                                If "ALL", all mixes are homogenized together in the output EDITION / COMPO file.
                                If "numbering" : the mix_connectivity_dict is used to determine the homogenization, based on unique regions, enrichments etc ...
    Returns:    
    ----------
    merg_mix_argument : str
        Formatted string for the MERG MIX argument.
    """
    
    MERGMIX_LIST = np.zeros(len(mix_connectivity_dict), dtype=int) # Index in MERGMIX_LIST corresponds to the mix number from chosen mix numbering option
    # Number (integer) entry in MERGMIX_LIST corresponds to the new mix number that will be used in to identify the calculated homogenized properties in the output COMPO. 
    # Ie this is the unique_id given to a specific mix.
    mergmix_argument = ""
    for key in mix_connectivity_dict.keys():
        mix_index = mix_connectivity_dict[key]
        if key.startswith("FMIX_"):
            _, composition_id, unique_id, ring_id = key.split("_")
            if spatial_homogenisation == "numbering":
                MERGMIX_LIST[mix_index-1] = int(unique_id)  # Store the unique ID in the MERGMIX_LIST at the index corresponding to the mix number
            elif spatial_homogenisation == "FUEL" or spatial_homogenisation == "ALL":
                # If spatial homogenisation is FUEL, we use the ring_id as the unique identifier for the mix
                MERGMIX_LIST[mix_index-1] = 1
        else:
            unique_id = key
            if spatial_homogenisation == "numbering" or spatial_homogenisation == "FUEL": # Exclude non-fuel mixes from the MERG MIX argument
                MERGMIX_LIST[mix_index-1] = 0
            elif spatial_homogenisation == "ALL":
                MERGMIX_LIST[mix_index-1] = 1
        
        #print(f"Processing mix {key} with index {mix_index} and unique ID {unique_id}")
    # Format MERGMIX_LIST to create the mergmix_argument
    for index, unique_id in enumerate(MERGMIX_LIST):
        mergmix_argument += f"{unique_id} "
        if index % 10 == 9:
            mergmix_argument += "\n"
    #print(f"Generated MERG MIX argument: {mergmix_argument.strip()}")

    return mergmix_argument.strip()

def fill_COMPO_call(DIRNAME):
    """
    Fill calls to COMPO: module based on the DIRNAME provided in the initialization.
    """
    compo_call = (
    "COMPO := COMPO: COMPO EDIRATES LIBRARY2 ::\n"
    "   EDIT 1\n"
    f"    STEP UP {DIRNAME}\n"
    ";\n"
    )
    return compo_call.strip()


def ediCompoBU(compo_bu_lcm, flux_lcm, self_shielded_microlib, track_lcm, burnup_lcm, BU):
    """
    This function prepares a DRAGON5 EDI: and COMPO: procedure call specifically for burnup calculations.
    """
    
    # Call EDICPO_BU procedure
    # Initialize the LIFO stack
    ipLifo = lifo.new()
    # Push necessary data onto the LIFO stack
    if BU > 0:
        ipLifo.push(compo_bu_lcm)
    else:
        ipLifo.pushEmpty("COMPOBU", "LCM")
    ipLifo.push(flux_lcm)
    ipLifo.push(self_shielded_microlib)
    ipLifo.push(track_lcm)
    ipLifo.push(burnup_lcm)
    ipLifo.push(BU)  # Burnup step in MWd/tU
    
    # Create a cle2000 object to handle the EDI: and COMPO: procedure call
    edi_compo_proc = cle2000.new('EDICPO_BU', ipLifo, 1)
    # Execute the EDI_COMPO procedure
    edi_compo_proc.exec()
    # Recover the results from the LIFO stack
    ipLifo.lib()
    compo_bu_lcm = ipLifo.node('COMPOBU')
    # Clear stack before next execution
    while ipLifo.getMax() > 0:
        ipLifo.pop();
    
    return compo_bu_lcm

def saveCpoToFile(compo_bu_lcm, compo_rates_lcm, file_name_cpo_bu, file_name_cpo_rates):
    """
    Save the composition LCM object to a file in ASCII format.
    Parameters:
    ----------
    compo_lcm : lcm object
        LCM object containing the composition data.
    file_name : str
        Name of the file to save the composition data.
    """
    # Save compo_bu_lcm to file
    myLifo = lifo.new()
    myLifo.push(compo_bu_lcm)
    myLifo.push(compo_rates_lcm)
    myLifo.push(file_name_cpo_bu)
    myLifo.push(file_name_cpo_rates)
    
    save_proc = cle2000.new('SAVE_CPOS', myLifo, 1)
    save_proc.exec()
    # Clear stack
    while myLifo.getMax() > 0:
        myLifo.pop();
        
    return
